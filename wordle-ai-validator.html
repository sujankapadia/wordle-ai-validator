<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wordle Rule Validator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for a nicer look */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
            color: #1f2937;
        }
        .container {
            max-width: 900px;
        }
        .card {
            background-color: white;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .rule-item {
            padding: 4px 8px;
            margin: 2px;
            font-size: 0.875rem;
            border-radius: 9999px;
            display: inline-flex;
            align-items: center;
        }
        .present { background-color: #fcd34d; color: #111827; } /* Yellow/Orange */
        .exact { background-color: #34d399; color: #111827; } /* Green */
        .absent { background-color: #9ca3af; color: white; } /* Gray */
        #ruleInput, #results, #wordListInput {
            transition: all 0.2s;
        }
        /* Spinner CSS */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-left-color: #ffffff;
            border-radius: 50%;
            width: 1.5rem;
            height: 1.5rem;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="p-4 sm:p-8">
    <div class="container mx-auto">
        <header class="text-center mb-10">
            <h1 class="text-4xl font-extrabold text-blue-600 mb-2">Wordle Rule Validator</h1>
            <p class="text-lg text-gray-600">AI-Assisted deterministic filtering for Wordle.</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">

            <!-- RULES GENERATION & INPUT -->
            <div class="lg:col-span-2 card p-6 rounded-xl">
                
                <!-- API Key Input -->
                <h2 class="text-xl font-semibold mb-2 text-gray-700">API Configuration</h2>
                <input type="text" id="apiKeyInput"
                       class="w-full p-3 border-2 border-gray-300 rounded-lg focus:border-red-500 focus:ring-red-500 mb-6"
                       placeholder="Enter your Gemini API Key here (required for Step 1)" />

                <!-- LLM Prompt Section -->
                <h2 class="text-2xl font-semibold mb-4 text-purple-700">1. Describe Your Rules (Natural Language)</h2>
                <textarea id="promptInput"
                          class="w-full h-24 p-3 border-2 border-purple-300 rounded-lg focus:border-purple-500 focus:ring-purple-500"
                          placeholder="e.g., The word has 'A' in it, 'O' is the third letter, and no S, T, R, E, C, L, U, D. The word must be 6 letters long.">The word has 'A' in it, 'O' is the third letter, and no S, T, R, E, C, L, U, D</textarea>

                <button onclick="generateDslAndValidate()" id="generateButton" class="mt-4 w-full bg-purple-600 text-white py-3 rounded-lg font-bold hover:bg-purple-700 transition duration-150 relative flex items-center justify-center">
                    <span id="buttonText">Generate Rules & Run Validator</span>
                    <div id="loadingIndicator" class="absolute right-4 hidden">
                        <div class="spinner"></div>
                    </div>
                </button>

                <!-- Validated DSL Output Section -->
                <h2 class="text-2xl font-semibold mt-8 mb-4 text-gray-700 border-t pt-4">2. Validated DSL Input</h2>
                <p class="text-sm text-gray-500 mb-3">
                    This is the machine-readable format generated by the AI (or you can edit it manually).
                    <br>
                    <span class="font-bold text-green-600">Exact Match:</span> `A at 1` &bull;
                    <span class="font-bold text-yellow-600">Present:</span> `A in word` &bull;
                    <span class="font-bold text-gray-600">Absent:</span> `no S, T` &bull;
                    <span class="font-bold text-blue-600">Length:</span> `LENGTH: 5`
                </p>

                <!-- Existing ruleInput, now primarily for generated/manual DSL -->
                <textarea id="ruleInput"
                          class="w-full h-40 p-3 border-2 border-blue-300 rounded-lg focus:border-blue-500 focus:ring-blue-500 font-mono text-sm"
                          placeholder="DSL rules generated here..."></textarea>

                <button onclick="applyRules()"
                        class="mt-4 w-full bg-blue-600 text-white py-3 rounded-lg font-bold hover:bg-blue-700 transition duration-150">
                    Run Validator Manually
                </button>
            </div>

            <!-- WORD LIST / RESULTS (Swapped Order) -->
            <div class="lg:col-span-1">
            
                <!-- Word List Card (Now Step 3) -->
                <div class="card p-6 rounded-xl mb-6">
                    <h2 class="text-2xl font-semibold mb-4 text-gray-700">3. Word List (Dictionary)</h2>
                    <p class="text-sm text-gray-500 mb-2">
                        Enter words, separated by newlines. Only words matching the required length will be validated. <span id="wordListCount" class="font-semibold"></span>
                    </p>
                    <textarea id="wordListInput"
                              class="w-full h-40 p-3 border-2 border-gray-300 rounded-lg text-sm focus:border-blue-500 focus:ring-blue-500">AGONY
AMONG
GUMBO
GAMES
FIGHT
WAGON
KAYAK
MAMBA
BABY
PIANO
QUERY
SWIRL
ZAZOO</textarea>
                </div>

                <!-- Results Card (Now Step 4) -->
                <div class="card p-6 rounded-xl">
                    <h2 class="text-2xl font-semibold mb-4 text-gray-700">4. Results (<span id="resultCount">0</span> Words)</h2>
                    <div id="results" class="space-y-2 h-40 overflow-y-auto p-2 border border-gray-200 rounded-lg bg-gray-50">
                        <p class="text-gray-500 text-sm">Use the buttons to generate or run validation.</p>
                    </div>
                </div>

            </div>

        </div>
    </div>

    <script>
        const $ = id => document.getElementById(id);
        const API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent";
        
        /**
         * Core logic to handle the API call with exponential backoff.
         * @param {object} payload - The request body for the Gemini API.
         * @param {number} maxRetries - Maximum number of retries.
         * @param {number} delay - Initial delay in milliseconds.
         * @returns {Promise<object>} The successful response JSON.
         */
        async function handleApiCall(payload, maxRetries = 5, delay = 1000) {
            const apiKey = $('apiKeyInput').value.trim();
            const fullApiUrl = `${API_URL}?key=${apiKey}`;

            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(fullApiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.ok) {
                        return await response.json();
                    } else if (response.status === 429 && i < maxRetries - 1) {
                        // Rate limiting error, proceed with retry
                        console.warn(`API Rate Limit Hit. Retrying in ${delay}ms...`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2; // Exponential backoff
                    } else {
                        // Other errors or final rate limit failure
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(`API call failed with status: ${response.status}. Message: ${errorData.error?.message || response.statusText}`);
                    }
                } catch (error) {
                    if (i === maxRetries - 1) {
                        console.error("Final API call attempt failed.", error);
                        throw error;
                    }
                    console.warn(`API Request failed: ${error.message}. Retrying in ${delay}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2; // Exponential backoff
                }
            }
        }


        /**
         * Calls the LLM to convert a natural language prompt into the DSL format.
         */
        async function generateDslAndValidate() {
            const apiKey = $('apiKeyInput').value.trim();
            if (!apiKey) {
                console.error("Please enter a valid API Key to use the generator.");
                $('ruleInput').value = "ERROR: Please enter your Gemini API Key above.";
                $('resultCount').textContent = 0;
                $('results').innerHTML = '<p class="text-red-500 font-semibold p-2">API Key is required for rule generation.</p>';
                return;
            }

            const prompt = $('promptInput').value.trim();
            if (!prompt) {
                console.error("Please enter a rule description.");
                return;
            }

            // Set loading state
            $('loadingIndicator').classList.remove('hidden');
            $('buttonText').textContent = 'Generating...';
            $('generateButton').disabled = true;
            $('ruleInput').value = 'Generating DSL rules from prompt...';

            try {
                const systemPrompt = `You are a Wordle Rule Translator. Your task is to convert a natural language description of Wordle constraints into a structured Domain Specific Language (DSL) format.
The word length should be included as a rule if specified by the user (e.g., "6 letters long"). If the user does not mention length, assume 5 and include 'LENGTH: 5' explicitly.
The DSL format is:
1. Exact Match (Green): [LETTER] at [POSITION_NUMBER] (e.g., 'A at 1', 'O at 3')
2. Present (Yellow): [LETTER] in word (e.g., 'A in word')
3. Absent (Gray): no [LETTERS, comma separated] (e.g., 'no S, T, R, E')
4. For yellow letters that cannot be in a specific spot: [LETTER] in word, not at [POSITION_NUMBER, comma separated] (e.g., 'Y in word, not at 5')
5. Word Length: LENGTH: [NUMBER] (e.g., 'LENGTH: 5')

Output ONLY a JSON object containing a single key 'dsl_rules' with the DSL block as a string value. Preserve newlines in the DSL string.

Example Input: "The word has 'A' in it, 'O' is the third letter, and no S, T, R. The word is 6 letters long."
Example Output:
{
  "dsl_rules": "O at 3\\nA in word\\nno S, T, R\\nLENGTH: 6"
}
`;

                const payload = {
                    contents: [{ parts: [{ text: prompt }] }],
                    systemInstruction: { parts: [{ text: systemPrompt }] },
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "OBJECT",
                            properties: {
                                "dsl_rules": { "type": "STRING" }
                            }
                        }
                    }
                };
                
                const result = await handleApiCall(payload);
                const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;

                if (jsonText) {
                    const parsedJson = JSON.parse(jsonText);
                    const dslRules = parsedJson.dsl_rules;

                    $('ruleInput').value = dslRules.trim();
                    applyRules(); // Run validator immediately
                } else {
                    $('ruleInput').value = "Error: Could not generate DSL. Check console for details.";
                    $('resultCount').textContent = 0;
                    $('results').innerHTML = '<p class="text-red-500 font-semibold p-2">Failed to generate rules from prompt.</p>';
                }

            } catch (error) {
                console.error("Error during LLM call:", error);
                $('ruleInput').value = `Error generating DSL: ${error.message}`;
                $('resultCount').textContent = 0;
                $('results').innerHTML = '<p class="text-red-500 font-semibold p-2">An API error occurred. Check API Key or console.</p>';
            } finally {
                // Reset loading state
                $('loadingIndicator').classList.add('hidden');
                $('buttonText').textContent = 'Generate Rules & Run Validator';
                $('generateButton').disabled = false;
            }
        }


        // --- DSL Validation Logic ---

        /**
         * Parses the raw text rules into a structured DSL object.
         */
        function parseRules(rawRules) {
            const rules = {
                exact: {},
                present: {},
                absent: new Set(),
                length: 5, // Default Wordle length
            };

            const lines = rawRules.toUpperCase().split('\n').map(line => line.trim()).filter(line => line.length > 0);

            for (const line of lines) {
                // 1. Exact Match (Green): 'O at 3', 'A at 1' (0-based index)
                const exactMatch = line.match(/^([A-Z]) AT (\d)$/);
                if (exactMatch) {
                    const letter = exactMatch[1];
                    const position = parseInt(exactMatch[2], 10);
                    // Check if position is valid for standard 5-letter or potential larger words (we limit to 9 for now)
                    if (position >= 1 && position <= 9) { 
                        rules.exact[position - 1] = letter;
                        continue;
                    }
                }

                // 2. Absent (Gray): 'NO S, T, R, E' or 'NO S'
                const absentMatch = line.match(/^NO\s+([A-Z, ]+)$/);
                if (absentMatch) {
                    const letters = absentMatch[1].split(',').map(l => l.trim()).filter(l => l.length === 1);
                    letters.forEach(letter => rules.absent.add(letter));
                    continue;
                }

                // 3. Present (Yellow): 'A IN WORD', 'Y IN WORD, NOT AT 5'
                const presentMatch = line.match(/^([A-Z]) IN WORD/);
                if (presentMatch) {
                    const letter = presentMatch[1];
                    let disallowedPositions = [];

                    // Check for optional "NOT AT" clause
                    const notAtMatch = line.match(/NOT AT ([\d, ]+)$/);
                    if (notAtMatch) {
                        disallowedPositions = notAtMatch[1].split(',')
                            .map(p => parseInt(p.trim(), 10) - 1) // Convert to 0-based
                            .filter(p => p >= 0); // Allow any position number to be excluded
                    }

                    rules.present[letter] = disallowedPositions;
                    continue;
                }

                // 4. Word Length: 'LENGTH: 5'
                const lengthMatch = line.match(/^LENGTH:\s*(\d+)$/);
                if (lengthMatch) {
                    rules.length = parseInt(lengthMatch[1], 10);
                    continue;
                }

                console.warn(`Unrecognized rule format: ${line}`);
            }

            rules.absent = Array.from(rules.absent);
            return rules;
        }

        /**
         * Checks if a single word satisfies all the given Wordle rules.
         */
        function validateWord(word, rules) {
            // 0. Check Length Constraint
            if (word.length !== rules.length) {
                return false;
            }

            // 1. Check Exact Matches (Green)
            // Need to ensure the index is within the word's bounds, although rules.length handles the main check.
            for (const indexStr in rules.exact) {
                const index = parseInt(indexStr);
                if (index < word.length && word[index] !== rules.exact[index]) {
                    return false;
                }
            }

            // 2. Check Absent Letters (Gray)
            for (const letter of rules.absent) {
                if (word.includes(letter)) {
                    return false;
                }
            }

            // 3. Check Present Letters (Yellow)
            for (const letter in rules.present) {
                // Check 3a: Letter MUST be present in the word
                if (!word.includes(letter)) {
                    return false;
                }

                // Check 3b: Letter MUST NOT be in the disallowed positions
                const disallowedPositions = rules.present[letter];
                for (const index of disallowedPositions) {
                    if (index < word.length && word[index] === letter) {
                        return false;
                    }
                }
            }

            return true;
        }

        /**
         * Main function to run the validator and update the UI.
         */
        function applyRules() {
            const rawRules = $('ruleInput').value;
            const rawWordList = $('wordListInput').value;
            
            // Clean and normalize word list
            const wordList = rawWordList.toUpperCase().split('\n')
                .map(w => w.trim())
                .filter(w => w.length > 0); 

            const rules = parseRules(rawRules);
            const resultsDiv = $('results');
            resultsDiv.innerHTML = '';
            let validWords = 0;

            wordList.forEach(word => {
                if (validateWord(word, rules)) {
                    validWords++;
                    const wordElement = document.createElement('div');
                    wordElement.className = 'text-lg font-mono p-2 bg-white border border-green-300 rounded-lg hover:bg-green-50 cursor-pointer';
                    wordElement.textContent = word;
                    resultsDiv.appendChild(wordElement);
                }
            });

            $('resultCount').textContent = validWords;
            $('wordListCount').textContent = `(${wordList.length} total words in list)`;

            if (validWords === 0) {
                resultsDiv.innerHTML = '<p class="text-red-500 font-semibold p-2">No words found that satisfy all constraints.</p>';
            }

            console.log("--- Rule Parsing Summary ---");
            console.log("Rules:", rules);
            console.log("Valid Words:", validWords);
        }

        // Initialize the word count on load and run initial validation (if rules are present)
        window.onload = function() {
            // Set initial rules (from the chat example) and run validator
            $('ruleInput').value = "O at 3\nA in word\nno S, T, R, E, C, L, U, D\nLENGTH: 5";
            applyRules();
        };

    </script>
</body>
</html>