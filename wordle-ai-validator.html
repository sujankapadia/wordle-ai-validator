<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wordle Rule Validator (API Filter)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for a nicer look */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
            color: #1f2937;
        }
        .container {
            max-width: 900px;
        }
        .card {
            background-color: white;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        /* Styling for the Validation Status */
        .validation-status {
            font-size: 0.875rem;
            padding: 4px;
            border-radius: 6px;
        }
        .text-info { background-color: #bfdbfe; color: #1e40af; }
        .text-error { background-color: #fecaca; color: #b91c1c; }
        
        /* Spinner CSS */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-left-color: #ffffff;
            border-radius: 50%;
            width: 1.5rem;
            height: 1.5rem;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Wordle-style letter tiles */
        .word-row {
            display: flex;
            gap: 5px;
            margin-bottom: 8px;
            justify-content: flex-start;
        }

        .letter-tile {
            width: 50px;
            height: 50px;
            border: 2px solid #d3d6da;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            text-transform: uppercase;
            color: white;
            border-radius: 2px;
        }

        .letter-tile.green {
            background-color: #6aaa64;
            border-color: #6aaa64;
        }

        .letter-tile.yellow {
            background-color: #c9b458;
            border-color: #c9b458;
        }

        .letter-tile.gray {
            background-color: #787c7e;
            border-color: #787c7e;
        }

        .letter-tile.default {
            background-color: #d3d6da;
            border-color: #d3d6da;
            color: #1f2937;
        }

        .word-row:hover .letter-tile {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        .letter-tile {
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        /* Responsive tile sizing */
        @media (max-width: 640px) {
            .letter-tile {
                width: 40px;
                height: 40px;
                font-size: 20px;
            }
        }
    </style>
</head>
<body class="p-4 sm:p-8">
    <div class="container mx-auto">
        <header class="text-center mb-10">
            <h1 class="text-4xl font-extrabold text-blue-600 mb-2">Wordle Rule Validator</h1>
            <p class="text-lg text-gray-600">Using Gemini AI to translate rules, then fetching valid Scrabble words from bestwordlist.com</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">

            <!-- RULES GENERATION & INPUT -->
            <div class="lg:col-span-2 card p-6 rounded-xl">
                
                <!-- API Key Input -->
                <h2 class="text-xl font-semibold mb-2 text-gray-700">API Configuration</h2>
                <input type="text" id="apiKeyInput"
                       class="w-full p-3 border-2 border-gray-300 rounded-lg focus:border-red-500 focus:ring-red-500 mb-6"
                       placeholder="Enter your Gemini API Key here (required for LLM steps)" />

                <!-- LLM Prompt Section -->
                <h2 class="text-2xl font-semibold mb-4 text-purple-700">1. Describe Your Rules (Natural Language)</h2>
                <textarea id="promptInput"
                          class="w-full h-24 p-3 border-2 border-purple-300 rounded-lg focus:border-purple-500 focus:ring-purple-500"
                          placeholder="e.g., The word has 'A' in it, 'O' is the third letter, and no S, T, R, E, C, L, U, D. The word must be 6 letters long.">The word has 'A' in it, 'O' is the third letter, and no S, T, R, E, C, L, U, D</textarea>

                <button onclick="generateDslAndFetchWords()" id="generateButton" class="mt-4 w-full bg-purple-600 text-white py-3 rounded-lg font-bold hover:bg-purple-700 transition duration-150 relative flex items-center justify-center">
                    <span id="buttonText">Generate DSL & Fetch Words</span>
                    <div id="loadingIndicator" class="absolute right-4 hidden">
                        <div class="spinner"></div>
                    </div>
                </button>

                <!-- Validated DSL Output Section -->
                <h2 class="text-2xl font-semibold mt-8 mb-4 text-gray-700 border-t pt-4">2. Validated DSL Input</h2>
                <p class="text-sm text-gray-500 mb-3">
                    This uses the strict, preferred DSL format: `[LETTER] at [POS]`, `[LETTER] in word`, `no [LETTERS]`.
                </p>

                <textarea id="ruleInput"
                          class="w-full h-40 p-3 border-2 border-blue-300 rounded-lg focus:border-blue-500 focus:ring-blue-500 font-mono text-sm"
                          placeholder="DSL rules generated here..."></textarea>
            </div>

            <!-- RESULTS -->
            <div class="lg:col-span-1">

                <!-- Results Card -->
                <div class="card p-6 rounded-xl">
                    <h2 class="text-2xl font-semibold mb-4 text-gray-700">3. Results (<span id="resultCount">0</span> Words)</h2>
                    <p class="text-sm text-gray-500 mb-2">
                        Valid Scrabble words sorted by commonness. <span id="wordListCount" class="font-semibold"></span>
                    </p>
                    <div id="validationStatus" class="validation-status text-info mb-3">
                        Ready to fetch words.
                    </div>

                    <div id="results" class="grid grid-cols-1 gap-2 h-96 overflow-y-auto p-4 border border-purple-200 rounded-lg bg-purple-50 text-purple-900 font-['Clear_Sans','Arial','Helvetica',sans-serif] uppercase">
                        <p class="text-purple-700 text-sm">Click "Generate DSL & Fetch Words" above to see results.</p>
                    </div>
                </div>

            </div>

        </div>
    </div>

    <script>
        const $ = id => document.getElementById(id);
        const GEMINI_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent";
        const CORS_PROXY = "https://corsproxy.io/?";
        const WORD_FREQ_URL = "https://norvig.com/ngrams/count_1w.txt";

        // Define a hard timeout for the Gemini API call (20 seconds)
        const GEMINI_TIMEOUT_MS = 20000;

        // Word frequency cache
        const WORD_FREQ = {};
        let WORD_FREQ_LOADED = false; 

        /**
         * Core logic to handle the Gemini API call with exponential backoff and a hard timeout.
         */
        async function handleGeminiApiCall(payload, maxRetries = 5, delay = 1000) {
            console.log("Starting Gemini API call...");
            const apiKey = $('apiKeyInput').value.trim();
            const fullApiUrl = `${GEMINI_API_URL}?key=${apiKey}`;

            if (!apiKey) {
                throw new Error("API Key is required.");
            }

            for (let i = 0; i < maxRetries; i++) {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), GEMINI_TIMEOUT_MS);
                
                try {
                    const response = await fetch(fullApiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload),
                        signal: controller.signal // Apply the timeout signal
                    });
                    
                    clearTimeout(timeoutId); // Clear timeout if fetch succeeds/fails quickly
                    
                    console.log(`Gemini API response received. Status: ${response.status}`);

                    if (response.ok) {
                        return await response.json();
                    } else if (response.status === 429 && i < maxRetries - 1) {
                        console.warn(`Gemini API Rate Limit Hit. Retrying in ${delay}ms...`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2; 
                    } else {
                        let errorBody = {};
                        try {
                            errorBody = await response.json();
                        } catch (e) {
                            console.error("Failed to parse error response body as JSON. Response may be plain text or HTML error.", e);
                            // errorBody remains an empty object
                        }
                        throw new Error(`Gemini API call failed with status: ${response.status}. Message: ${errorBody.error?.message || response.statusText}. Check the console for more details.`);
                    }
                } catch (error) {
                    clearTimeout(timeoutId); // Ensure timeout is cleared even on error
                    
                    if (error.name === 'AbortError') {
                        error = new Error(`Gemini API call timed out after ${GEMINI_TIMEOUT_MS / 1000} seconds.`);
                    }

                    if (i === maxRetries - 1) {
                        console.error("Final Gemini API call attempt failed.", error);
                        throw error;
                    }
                    console.warn(`Gemini API Request failed: ${error.message}. Retrying in ${delay}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2; 
                }
            }
        }


        /**
         * IndexedDB helper functions for word frequency caching
         */
        const DB_NAME = 'WordleValidatorDB';
        const DB_VERSION = 1;
        const STORE_NAME = 'wordFrequencies';

        function openDatabase() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve(request.result);

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME);
                    }
                };
            });
        }

        async function getCachedWordFrequencies() {
            try {
                const db = await openDatabase();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction(STORE_NAME, 'readonly');
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.get('frequencies');

                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            } catch (e) {
                console.error('Error reading from IndexedDB:', e);
                return null;
            }
        }

        async function setCachedWordFrequencies(data) {
            try {
                const db = await openDatabase();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction(STORE_NAME, 'readwrite');
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.put(data, 'frequencies');

                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            } catch (e) {
                console.error('Error writing to IndexedDB:', e);
            }
        }

        /**
         * Load word frequencies from Peter Norvig's dataset
         */
        async function loadWordFrequencies() {
            console.log('Loading word frequencies from', WORD_FREQ_URL);
            try {
                // Use CORS proxy (direct fetch is blocked by CORS)
                const response = await fetch(CORS_PROXY + WORD_FREQ_URL);

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const text = await response.text();
                const lines = text.split('\n');

                for (const line of lines) {
                    const parts = line.split('\t');
                    if (parts.length >= 2) {
                        const word = parts[0].trim().toUpperCase();
                        const count = parseInt(parts[1].trim());
                        if (word && !isNaN(count)) {
                            WORD_FREQ[word] = count;
                        }
                    }
                }

                console.log(`Loaded ${Object.keys(WORD_FREQ).length} word frequencies`);
            } catch (error) {
                console.error('Error loading word frequencies:', error);
                // Continue without word frequency data
            }
        }

        /**
         * Ensure word frequencies are loaded (with IndexedDB caching)
         */
        async function ensureWordFrequenciesLoaded() {
            if (WORD_FREQ_LOADED) return;

            // Check IndexedDB cache first
            const cached = await getCachedWordFrequencies();
            const ONE_WEEK = 7 * 24 * 60 * 60 * 1000;

            if (cached && cached.data && cached.timestamp &&
                (Date.now() - cached.timestamp) < ONE_WEEK) {
                // Use cached data
                Object.assign(WORD_FREQ, cached.data);
                console.log(`Loaded ${Object.keys(WORD_FREQ).length} word frequencies from IndexedDB cache`);
            } else {
                // Fetch fresh data
                await loadWordFrequencies();

                // Cache in IndexedDB
                try {
                    await setCachedWordFrequencies({
                        data: WORD_FREQ,
                        timestamp: Date.now()
                    });
                    console.log('Cached word frequencies in IndexedDB');
                } catch (e) {
                    console.warn('Could not cache word frequencies in IndexedDB:', e);
                }
            }

            WORD_FREQ_LOADED = true;
        }

        /**
         * Get word frequency score (returns 0 if not found)
         */
        function getWordFrequency(word) {
            return WORD_FREQ[word.toUpperCase()] || 0;
        }


        /**
         * Extract words from a page's HTML
         */
        function extractWordsFromHtml(html, wordLength) {
            // Remove all <b> tags to get clean words
            const cleanHtml = html.replace(/<b>|<\/b>/g, '');

            // Remove all red spans (invalid words)
            const redSpanRegex = /<span class=rd>(.*?)<\/span>/g;
            const htmlWithoutRed = cleanHtml.replace(redSpanRegex, '');

            // Extract all words of the specified length
            const wordRegex = new RegExp(`\\b([A-Z]{${wordLength}})\\b`, 'g');
            const matches = [];
            let match;
            while ((match = wordRegex.exec(htmlWithoutRed)) !== null) {
                const word = match[1];
                if (word.length === wordLength && /^[A-Z]+$/.test(word)) {
                    matches.push(word);
                }
            }

            return matches;
        }

        /**
         * Check if a page has pagination and extract the next page number
         */
        function getNextPageNumber(html) {
            // Look for pagination links like: <link rel=next href=words5lettersfirstletterapage2.htm>
            const nextPageMatch = html.match(/<link rel=next href=[^>]*page(\d+)\.htm>/);
            if (nextPageMatch) {
                return parseInt(nextPageMatch[1], 10);
            }
            return null;
        }

        /**
         * Calculate allowed positions for a "present" letter based on disallowed positions
         */
        function getAllowedPositions(wordLength, disallowedPositions) {
            const allPositions = Array.from({ length: wordLength }, (_, i) => i);
            return allPositions.filter(pos => !disallowedPositions.includes(pos));
        }

        /**
         * Fetch words from a specific letter-position URL with pagination
         */
        async function fetchWordsFromPosition(letter, position, wordLength) {
            const positionNames = ['first', 'second', 'third', 'fourth', 'fifth'];
            const positionName = positionNames[position] || `position${position + 1}`;

            const baseUrl = `${CORS_PROXY}https://www.bestwordlist.com/p/${letter.toLowerCase()}/1/words${wordLength}letters${positionName}letter${letter.toLowerCase()}`;
            const page1Url = `${baseUrl}.htm`;

            const allWords = [];
            let currentPage = 1;
            let hasMorePages = true;

            try {
                while (hasMorePages) {
                    const pageUrl = currentPage === 1
                        ? page1Url
                        : `${baseUrl}page${currentPage}.htm`;

                    console.log(`  Fetching page ${currentPage}: ${pageUrl}`);
                    $('validationStatus').textContent = `Fetching ${letter} at position ${position + 1}, page ${currentPage}...`;

                    const response = await fetch(pageUrl);
                    if (!response.ok) {
                        if (response.status === 404 && currentPage > 1) {
                            console.log(`  Page ${currentPage} not found. Finished pagination.`);
                            break;
                        }
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const html = await response.text();
                    const pageWords = extractWordsFromHtml(html, wordLength);
                    console.log(`    Found ${pageWords.length} words on page ${currentPage}`);
                    allWords.push(...pageWords);

                    // Check for next page
                    const nextPageNum = getNextPageNumber(html);
                    if (nextPageNum && nextPageNum === currentPage + 1) {
                        currentPage = nextPageNum;
                        await new Promise(resolve => setTimeout(resolve, 100));
                    } else {
                        hasMorePages = false;
                    }
                }

                return allWords;

            } catch (error) {
                console.error(`  Error fetching ${letter} at position ${position + 1}: ${error.message}`);
                return [];
            }
        }

        /**
         * Fetch word list from bestwordlist.com based on exact or present position requirements
         * Handles pagination to fetch all words across multiple pages
         */
        async function fetchWordListByPosition(rules) {
            const positionNames = ['first', 'second', 'third', 'fourth', 'fifth'];
            const allWords = [];

            // Strategy 1: If there are exact position requirements, use them
            const exactPositions = Object.keys(rules.exact).map(k => parseInt(k));

            if (exactPositions.length > 0) {
                console.log("Found exact position constraints. Using first exact position.");

                const position = exactPositions[0];
                const letter = rules.exact[position];

                console.log(`Fetching words with ${letter} at position ${position + 1}...`);
                const words = await fetchWordsFromPosition(letter, position, rules.length);
                allWords.push(...words);

                console.log(`Found ${words.length} words with ${letter} at position ${position + 1}`);

            } else {
                // Strategy 2: No exact positions - use "present" constraints
                console.log("No exact position constraints found.");
                console.log("Finding best 'present' constraint to use for fetching...");

                // Find the "present" letter with the fewest allowed positions
                let bestLetter = null;
                let bestAllowedPositions = [];
                let minPositionCount = Infinity;

                for (const letter in rules.present) {
                    const disallowedPositions = rules.present[letter];
                    const allowedPositions = getAllowedPositions(rules.length, disallowedPositions);

                    console.log(`  Letter ${letter}: allowed at positions ${allowedPositions.map(p => p + 1).join(', ')} (${allowedPositions.length} total)`);

                    if (allowedPositions.length < minPositionCount && allowedPositions.length > 0) {
                        minPositionCount = allowedPositions.length;
                        bestLetter = letter;
                        bestAllowedPositions = allowedPositions;
                    }
                }

                if (!bestLetter || bestAllowedPositions.length === 0) {
                    console.log("No valid 'present' constraints found to use for fetching.");
                    $('validationStatus').textContent = 'No position constraints found. Cannot fetch words.';
                    return [];
                }

                console.log(`Selected letter: ${bestLetter} (${bestAllowedPositions.length} allowed positions)`);
                console.log(`Will fetch words with ${bestLetter} at positions: ${bestAllowedPositions.map(p => p + 1).join(', ')}`);

                // Fetch words for each allowed position
                for (const position of bestAllowedPositions) {
                    console.log(`Fetching words with ${bestLetter} at position ${position + 1}...`);
                    const words = await fetchWordsFromPosition(bestLetter, position, rules.length);
                    allWords.push(...words);
                    console.log(`  Found ${words.length} words with ${bestLetter} at position ${position + 1}`);
                }
            }

            const uniqueWords = Array.from(new Set(allWords));
            console.log(`Total: Found ${uniqueWords.length} unique words`);
            return uniqueWords;
        }

        /**
         * Step 1 & 2: Generates DSL rules and fetches candidate words from bestwordlist.com
         */
        async function generateDslAndFetchWords() {
            try {
                const apiKey = $('apiKeyInput').value.trim();
                if (!apiKey) {
                    $('results').innerHTML = '<p class="text-purple-900 font-semibold p-2 bg-purple-100 border border-purple-200 rounded">API Key is required.</p>';
                    return;
                }

                // Set loading state
                $('loadingIndicator').classList.remove('hidden');
                $('buttonText').textContent = 'Generating DSL...';
                $('generateButton').disabled = true;
                $('ruleInput').value = 'Generating DSL rules from prompt...';
                $('results').innerHTML = '<p class="text-purple-900 text-sm p-2 bg-purple-100 border border-purple-200 rounded">Step 1: Translating natural language to DSL...</p>';

                const prompt = $('promptInput').value.trim();
                if (!prompt) {
                    throw new Error("Please enter a rule description.");
                }

                // Prompt to generate ONLY DSL rules (not candidate words)
                const dslPrompt = `Convert the following Wordle constraints into a strict DSL format.

Output ONLY a JSON object with one key:
- 'dsl_rules': a string containing the DSL rules separated by newlines (\\n).

Each rule must be on its own line. For example:
"O at 3\\nA in word\\nno S, T, R, E\\nLENGTH: 5"

Constraints: ${prompt}`;

                // System instruction for DSL format only
                const systemPrompt = `You are a Wordle Rule Translator. You must output a single JSON object with only 'dsl_rules'.
If length is not specified, assume LENGTH: 5.
STRICTLY use the following DSL format with each rule on a separate line (separated by \\n):
- Exact position (Green): [LETTER] at [POSITION] (e.g., O at 3)
- Present in word (Yellow): [LETTER] in word (e.g., A in word)
- Present but NOT at specific positions (Yellow): [LETTER] in word, not at [POSITIONS] (e.g., A in word, not at 1, 2, 3)
- Absent (Gray): no [LETTERS, comma-separated] (e.g., no S, T, R, E)
- Length: LENGTH: [NUMBER] (e.g., LENGTH: 5)

IMPORTANT: When a letter must be in the word but its position is constrained (not allowed at certain positions), use the "in word, not at" format.

Example output:
{"dsl_rules": "O at 3\\nA in word\\nno S, T, R, E\\nLENGTH: 5"}`;

                const payload = {
                    contents: [{ parts: [{ text: dslPrompt }] }],
                    systemInstruction: { parts: [{ text: systemPrompt }] },
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "OBJECT",
                            properties: {
                                "dsl_rules": { "type": "STRING" }
                            }
                        }
                    }
                };

                const result = await handleGeminiApiCall(payload);
                const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;

                if (jsonText) {
                    const parsedJson = JSON.parse(jsonText);
                    const dslRules = parsedJson.dsl_rules ? parsedJson.dsl_rules.trim() : '';
                    $('ruleInput').value = dslRules || 'Error generating DSL.';

                    if (dslRules) {
                        // Parse the DSL rules
                        const rules = parseRules(dslRules);

                        // Fetch candidate words from bestwordlist.com
                        $('buttonText').textContent = 'Fetching Words...';
                        $('results').innerHTML = '<p class="text-purple-900 text-sm p-2 bg-purple-100 border border-purple-200 rounded">Step 2: Fetching words from bestwordlist.com...</p>';

                        const allWords = await fetchWordListByPosition(rules);

                        if (allWords.length === 0) {
                            $('results').innerHTML = '<p class="text-purple-900 font-semibold p-2 bg-purple-100 border border-purple-200 rounded">No words found. At least one position constraint is required.</p>';
                            return;
                        }

                        // Filter words based on all rules
                        $('validationStatus').textContent = 'Filtering words based on all constraints...';
                        const candidateWords = allWords.filter(word => checkDeterministicRules(word, rules));

                        // Load word frequencies and sort by commonness
                        $('validationStatus').textContent = 'Loading word frequencies and sorting...';
                        await ensureWordFrequenciesLoaded();

                        console.log('Sorting words by frequency...');
                        const sortedWords = candidateWords.sort((a, b) => {
                            const freqA = getWordFrequency(a);
                            const freqB = getWordFrequency(b);
                            console.log(`${a}: ${freqA}, ${b}: ${freqB}`);
                            return freqB - freqA; // Higher frequency first (more common)
                        });
                        console.log('Sorted words:', sortedWords);

                        // Display results
                        $('wordListCount').textContent = `(${sortedWords.length} found)`;
                        $('validationStatus').className = 'validation-status bg-green-200 text-green-800 ml-2';
                        $('validationStatus').textContent = `Found ${sortedWords.length} valid words!`;

                        const resultsDiv = $('results');
                        resultsDiv.innerHTML = '';
                        sortedWords.forEach(word => {
                            const freq = getWordFrequency(word);
                            const wordRow = createWordTiles(word.toUpperCase(), rules);

                            // Add frequency tooltip
                            if (freq > 0) {
                                wordRow.title = `Frequency: ${freq.toLocaleString()}`;
                            }

                            resultsDiv.appendChild(wordRow);
                        });
                        $('resultCount').textContent = sortedWords.length;
                    }
                } else {
                    $('ruleInput').value = "Error: Could not generate DSL. Check console for details.";
                    $('results').innerHTML = '<p class="text-purple-900 font-semibold p-2 bg-purple-100 border border-purple-200 rounded">Error: Could not generate DSL. Check console for details.</p>';
                    $('resultCount').textContent = 0;
                }

            } catch (error) {
                console.error("Error during word fetching:", error);
                $('ruleInput').value = `Error: ${error.message}`;
                $('results').innerHTML = `<p class="text-purple-900 font-semibold p-2 bg-purple-100 border border-purple-200 rounded">An error occurred: ${error.message.substring(0, 80)}</p>`;
            } finally {
                // Reset loading state
                $('loadingIndicator').classList.add('hidden');
                $('buttonText').textContent = 'Generate DSL & Fetch Words';
                $('generateButton').disabled = false;
            }
        }


        // --- DSL Validation Logic ---

        /**
         * Parses the raw text rules into a structured DSL object.
         */
        function parseRules(rawRules) {
            const rules = {
                exact: {},
                present: {},
                absent: new Set(),
                length: 5, // Default Wordle length
            };

            const lines = rawRules.toUpperCase().split('\n').map(line => line.trim()).filter(line => line.length > 0);

            for (const line of lines) {
                // 1. Exact Match (Green): 'O AT 3', 'A AT 1' (1-based index)
                const exactMatch = line.match(/^([A-Z]) AT (\d)$/);
                if (exactMatch) {
                    const position = parseInt(exactMatch[2], 10);
                    if (position >= 1 && position <= 9) { 
                        rules.exact[position - 1] = exactMatch[1];
                        continue;
                    }
                }

                // 2. Absent (Gray): 'NO S, T, R, E' or 'NO S'
                const absentMatch = line.match(/^NO\s+([A-Z, ]+)$/);
                if (absentMatch) {
                    const letters = absentMatch[1].split(',').map(l => l.trim()).filter(l => l.length === 1);
                    letters.forEach(letter => rules.absent.add(letter));
                    continue;
                }

                // 3. Present (Yellow): 'A IN WORD' or 'A IN WORD, NOT AT 5'
                const presentMatch = line.match(/^([A-Z]) IN WORD/);
                if (presentMatch) {
                    const letter = presentMatch[1];
                    let disallowedPositions = [];

                    const notAtMatch = line.match(/NOT AT ([\d, ]+)$/);
                    if (notAtMatch) {
                        disallowedPositions = notAtMatch[1].split(',')
                            .map(p => parseInt(p.trim(), 10) - 1) 
                            .filter(p => p >= 0); 
                    }

                    rules.present[letter] = disallowedPositions;
                    continue;
                }

                // 4. Word Length: 'LENGTH: 5'
                const lengthMatch = line.match(/^LENGTH:\s*(\d+)$/);
                if (lengthMatch) {
                    rules.length = parseInt(lengthMatch[1], 10);
                    continue;
                }
            }

            // Cleanup: ensure 'present' or 'exact' letters are not in the absent list
            for(const letter in rules.present) {
                rules.absent.delete(letter);
            }
            for(const index in rules.exact) {
                rules.absent.delete(rules.exact[index]);
            }

            rules.absent = Array.from(rules.absent);
            return rules;
        }

        /**
         * Determine the color class for a letter tile based on DSL rules
         */
        function getTileColor(letter, position, rules) {
            // Check if this position has an exact match (green)
            if (rules.exact[position] === letter) {
                return 'green';
            }

            // Check if letter is present but constrained (yellow)
            if (rules.present[letter]) {
                const disallowedPositions = rules.present[letter];
                // If the letter is at a disallowed position, it's yellow
                if (disallowedPositions.includes(position)) {
                    return 'yellow';
                }
            }

            // Check if letter is in the absent list (gray)
            if (rules.absent.includes(letter)) {
                return 'gray';
            }

            // Default: letter is unconstrained
            return 'default';
        }

        /**
         * Create Wordle-style tile display for a word
         */
        function createWordTiles(word, rules) {
            const container = document.createElement('div');
            container.className = 'word-row';

            for (let i = 0; i < word.length; i++) {
                const tile = document.createElement('div');
                const tileColor = getTileColor(word[i], i, rules);
                tile.className = `letter-tile ${tileColor}`;
                tile.textContent = word[i];
                container.appendChild(tile);
            }

            return container;
        }

        /**
         * Checks if a single word satisfies all the deterministic Wordle rules (excluding dictionary check).
         */
        function checkDeterministicRules(word, rules) {
            // 1. Check Length Constraint
            if (word.length !== rules.length) {
                return false;
            }

            // 2. Check Exact Matches (Green)
            for (const indexStr in rules.exact) {
                const index = parseInt(indexStr);
                if (word[index] !== rules.exact[index]) {
                    return false;
                }
            }

            // 3. Check Absent Letters (Gray)
            for (const letter of rules.absent) {
                if (word.includes(letter)) {
                    return false;
                }
            }

            // 4. Check Present Letters (Yellow)
            for (const letter in rules.present) {
                // Check 4a: Letter MUST be present in the word
                if (!word.includes(letter)) {
                    return false;
                }

                // Check 4b: Letter MUST NOT be in the disallowed positions
                const disallowedPositions = rules.present[letter];
                let isLetterInDisallowedPosition = false;
                for (const index of disallowedPositions) {
                    if (word[index] === letter) {
                        isLetterInDisallowedPosition = true;
                        break;
                    }
                }
                if (isLetterInDisallowedPosition) {
                    return false;
                }
            }
            
            return true;
        }

        // Initialize the app on load
        window.onload = function() {
            // Set initial rules using the preferred DSL format
            $('ruleInput').value = "O at 3\nA in word\nno S, T, R, E, C, L, U, D\nLENGTH: 5";
        };

    </script>
</body>
</html>
