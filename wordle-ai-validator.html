<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wordle Rule Validator (API Filter)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for a nicer look */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
            color: #1f2937;
        }
        .container {
            max-width: 900px;
        }
        .card {
            background-color: white;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        /* Styling for the Validation Status */
        .validation-status {
            font-size: 0.875rem;
            padding: 4px;
            border-radius: 6px;
        }
        .text-info { background-color: #bfdbfe; color: #1e40af; }
        .text-error { background-color: #fecaca; color: #b91c1c; }
        
        /* Spinner CSS */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-left-color: #ffffff;
            border-radius: 50%;
            width: 1.5rem;
            height: 1.5rem;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="p-4 sm:p-8">
    <div class="container mx-auto">
        <header class="text-center mb-10">
            <h1 class="text-4xl font-extrabold text-blue-600 mb-2">Wordle Rule Validator</h1>
            <p class="text-lg text-gray-600">Using Gemini AI to translate rules, then fetching valid Scrabble words from bestwordlist.com</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">

            <!-- RULES GENERATION & INPUT -->
            <div class="lg:col-span-2 card p-6 rounded-xl">
                
                <!-- API Key Input -->
                <h2 class="text-xl font-semibold mb-2 text-gray-700">API Configuration</h2>
                <input type="text" id="apiKeyInput"
                       class="w-full p-3 border-2 border-gray-300 rounded-lg focus:border-red-500 focus:ring-red-500 mb-6"
                       placeholder="Enter your Gemini API Key here (required for LLM steps)" />

                <!-- LLM Prompt Section -->
                <h2 class="text-2xl font-semibold mb-4 text-purple-700">1. Describe Your Rules (Natural Language)</h2>
                <textarea id="promptInput"
                          class="w-full h-24 p-3 border-2 border-purple-300 rounded-lg focus:border-purple-500 focus:ring-purple-500"
                          placeholder="e.g., The word has 'A' in it, 'O' is the third letter, and no S, T, R, E, C, L, U, D. The word must be 6 letters long.">The word has 'A' in it, 'O' is the third letter, and no S, T, R, E, C, L, U, D</textarea>

                <button onclick="generateDslAndFetchWords()" id="generateButton" class="mt-4 w-full bg-purple-600 text-white py-3 rounded-lg font-bold hover:bg-purple-700 transition duration-150 relative flex items-center justify-center">
                    <span id="buttonText">Generate DSL & Fetch Candidate Words</span>
                    <div id="loadingIndicator" class="absolute right-4 hidden">
                        <div class="spinner"></div>
                    </div>
                </button>

                <!-- Validated DSL Output Section -->
                <h2 class="text-2xl font-semibold mt-8 mb-4 text-gray-700 border-t pt-4">2. Validated DSL Input</h2>
                <p class="text-sm text-gray-500 mb-3">
                    This uses the strict, preferred DSL format: `[LETTER] at [POS]`, `[LETTER] in word`, `no [LETTERS]`.
                </p>

                <textarea id="ruleInput"
                          class="w-full h-40 p-3 border-2 border-blue-300 rounded-lg focus:border-blue-500 focus:ring-blue-500 font-mono text-sm"
                          placeholder="DSL rules generated here..."></textarea>
            </div>

            <!-- WORD LIST / RESULTS -->
            <div class="lg:col-span-1">
            
                <!-- Word List Card (Step 3) -->
                <div class="card p-6 rounded-xl mb-6">
                    <h2 class="text-2xl font-semibold mb-4 text-gray-700">3. Candidate Pool</h2>
                    <p class="text-sm text-gray-500 mb-2">
                        Valid Scrabble words fetched from bestwordlist.com. <span id="wordListCount" class="font-semibold"></span>
                    </p>
                    <div id="validationStatus" class="validation-status text-info mb-3">
                        Ready to fetch words.
                    </div>

                    <textarea id="wordListInput"
                              class="w-full h-40 p-3 border-2 border-gray-300 rounded-lg text-sm focus:border-blue-500 focus:ring-blue-500" readonly>Click "Generate DSL & Fetch Candidate Words" above to populate this list.</textarea>
                </div>

                <!-- Results Card (Step 4) -->
                <div class="card p-6 rounded-xl">
                    <h2 class="text-2xl font-semibold mb-4 text-gray-700">4. Results (<span id="resultCount">0</span> Words)</h2>
                    <div id="results" class="space-y-2 h-40 overflow-y-auto p-2 border border-gray-200 rounded-lg bg-gray-50">
                        <p class="text-gray-500 text-sm">Valid results will appear here.</p>
                    </div>
                </div>

            </div>

        </div>
    </div>

    <script>
        const $ = id => document.getElementById(id);
        const GEMINI_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent";
        const CORS_PROXY = "https://corsproxy.io/?";

        // Define a hard timeout for the Gemini API call (20 seconds)
        const GEMINI_TIMEOUT_MS = 20000; 

        /**
         * Core logic to handle the Gemini API call with exponential backoff and a hard timeout.
         */
        async function handleGeminiApiCall(payload, maxRetries = 5, delay = 1000) {
            console.log("Starting Gemini API call...");
            const apiKey = $('apiKeyInput').value.trim();
            const fullApiUrl = `${GEMINI_API_URL}?key=${apiKey}`;

            if (!apiKey) {
                throw new Error("API Key is required.");
            }

            for (let i = 0; i < maxRetries; i++) {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), GEMINI_TIMEOUT_MS);
                
                try {
                    const response = await fetch(fullApiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload),
                        signal: controller.signal // Apply the timeout signal
                    });
                    
                    clearTimeout(timeoutId); // Clear timeout if fetch succeeds/fails quickly
                    
                    console.log(`Gemini API response received. Status: ${response.status}`);

                    if (response.ok) {
                        return await response.json();
                    } else if (response.status === 429 && i < maxRetries - 1) {
                        console.warn(`Gemini API Rate Limit Hit. Retrying in ${delay}ms...`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2; 
                    } else {
                        let errorBody = {};
                        try {
                            errorBody = await response.json();
                        } catch (e) {
                            console.error("Failed to parse error response body as JSON. Response may be plain text or HTML error.", e);
                            // errorBody remains an empty object
                        }
                        throw new Error(`Gemini API call failed with status: ${response.status}. Message: ${errorBody.error?.message || response.statusText}. Check the console for more details.`);
                    }
                } catch (error) {
                    clearTimeout(timeoutId); // Ensure timeout is cleared even on error
                    
                    if (error.name === 'AbortError') {
                        error = new Error(`Gemini API call timed out after ${GEMINI_TIMEOUT_MS / 1000} seconds.`);
                    }

                    if (i === maxRetries - 1) {
                        console.error("Final Gemini API call attempt failed.", error);
                        throw error;
                    }
                    console.warn(`Gemini API Request failed: ${error.message}. Retrying in ${delay}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2; 
                }
            }
        }


        /**
         * Extract words from a page's HTML
         */
        function extractWordsFromHtml(html, wordLength) {
            // Remove all <b> tags to get clean words
            const cleanHtml = html.replace(/<b>|<\/b>/g, '');

            // Remove all red spans (invalid words)
            const redSpanRegex = /<span class=rd>(.*?)<\/span>/g;
            const htmlWithoutRed = cleanHtml.replace(redSpanRegex, '');

            // Extract all words of the specified length
            const wordRegex = new RegExp(`\\b([A-Z]{${wordLength}})\\b`, 'g');
            const matches = [];
            let match;
            while ((match = wordRegex.exec(htmlWithoutRed)) !== null) {
                const word = match[1];
                if (word.length === wordLength && /^[A-Z]+$/.test(word)) {
                    matches.push(word);
                }
            }

            return matches;
        }

        /**
         * Check if a page has pagination and extract the next page number
         */
        function getNextPageNumber(html) {
            // Look for pagination links like: <link rel=next href=words5lettersfirstletterapage2.htm>
            const nextPageMatch = html.match(/<link rel=next href=[^>]*page(\d+)\.htm>/);
            if (nextPageMatch) {
                return parseInt(nextPageMatch[1], 10);
            }
            return null;
        }

        /**
         * Fetch word list from bestwordlist.com based on exact position requirements
         * Handles pagination to fetch all words across multiple pages
         */
        async function fetchWordListByPosition(rules) {
            const exactPositions = Object.keys(rules.exact).map(k => parseInt(k));

            if (exactPositions.length === 0) {
                console.log("No exact position requirements found. Cannot fetch from bestwordlist.com.");
                return [];
            }

            const position = exactPositions[0];
            const letter = rules.exact[position];

            const positionNames = ['first', 'second', 'third', 'fourth', 'fifth'];
            const positionName = positionNames[position] || `position${position + 1}`;

            // Base URL pattern for page 1 (using CORS proxy)
            const baseUrl = `${CORS_PROXY}https://www.bestwordlist.com/p/${letter.toLowerCase()}/1/words${rules.length}letters${positionName}letter${letter.toLowerCase()}`;
            const page1Url = `${baseUrl}.htm`;

            console.log(`Fetching word list from: ${page1Url}`);

            const allWords = [];
            let currentPage = 1;
            let hasMorePages = true;

            try {
                while (hasMorePages) {
                    const pageUrl = currentPage === 1
                        ? page1Url
                        : `${baseUrl}page${currentPage}.htm`;

                    console.log(`Fetching page ${currentPage}: ${pageUrl}`);
                    $('validationStatus').textContent = `Fetching page ${currentPage} from bestwordlist.com...`;

                    const response = await fetch(pageUrl);
                    if (!response.ok) {
                        if (response.status === 404 && currentPage > 1) {
                            // No more pages
                            console.log(`Page ${currentPage} not found. Finished pagination.`);
                            break;
                        }
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const html = await response.text();

                    // Extract words from this page
                    const pageWords = extractWordsFromHtml(html, rules.length);
                    console.log(`  Found ${pageWords.length} words on page ${currentPage}`);
                    allWords.push(...pageWords);

                    // Check for next page
                    const nextPageNum = getNextPageNumber(html);
                    if (nextPageNum && nextPageNum === currentPage + 1) {
                        currentPage = nextPageNum;
                        // Small delay to be respectful to the server
                        await new Promise(resolve => setTimeout(resolve, 100));
                    } else {
                        hasMorePages = false;
                    }
                }

                const uniqueWords = Array.from(new Set(allWords));
                console.log(`Total: Found ${uniqueWords.length} unique valid words across ${currentPage} page(s)`);
                return uniqueWords;

            } catch (error) {
                console.error(`Error fetching word list: ${error.message}`);
                return [];
            }
        }

        /**
         * Step 1 & 2: Generates DSL rules and fetches candidate words from bestwordlist.com
         */
        async function generateDslAndFetchWords() {
            try {
                const apiKey = $('apiKeyInput').value.trim();
                if (!apiKey) {
                    $('results').innerHTML = '<p class="text-red-500 font-semibold p-2">API Key is required.</p>';
                    return;
                }

                // Set loading state
                $('loadingIndicator').classList.remove('hidden');
                $('buttonText').textContent = 'Generating DSL...';
                $('generateButton').disabled = true;
                $('ruleInput').value = 'Generating DSL rules from prompt...';
                $('wordListInput').value = 'Waiting for DSL generation...';
                $('results').innerHTML = '<p class="text-gray-500 text-sm p-2">Step 1: Translating natural language to DSL...</p>';

                const prompt = $('promptInput').value.trim();
                if (!prompt) {
                    throw new Error("Please enter a rule description.");
                }

                // Prompt to generate ONLY DSL rules (not candidate words)
                const dslPrompt = `Convert the following Wordle constraints into a strict DSL format.

Output ONLY a JSON object with one key:
- 'dsl_rules': a string containing the DSL rules separated by newlines (\\n).

Each rule must be on its own line. For example:
"O at 3\\nA in word\\nno S, T, R, E\\nLENGTH: 5"

Constraints: ${prompt}`;

                // System instruction for DSL format only
                const systemPrompt = `You are a Wordle Rule Translator. You must output a single JSON object with only 'dsl_rules'.
If length is not specified, assume LENGTH: 5.
STRICTLY use the following DSL format with each rule on a separate line (separated by \\n):
- Exact position (Green): [LETTER] at [POSITION] (e.g., O at 3)
- Present in word (Yellow): [LETTER] in word (e.g., A in word)
- Absent (Gray): no [LETTERS, comma-separated] (e.g., no S, T, R, E)
- Length: LENGTH: [NUMBER] (e.g., LENGTH: 5)

Example output:
{"dsl_rules": "O at 3\\nA in word\\nno S, T, R, E\\nLENGTH: 5"}`;

                const payload = {
                    contents: [{ parts: [{ text: dslPrompt }] }],
                    systemInstruction: { parts: [{ text: systemPrompt }] },
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "OBJECT",
                            properties: {
                                "dsl_rules": { "type": "STRING" }
                            }
                        }
                    }
                };

                const result = await handleGeminiApiCall(payload);
                const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;

                if (jsonText) {
                    const parsedJson = JSON.parse(jsonText);
                    const dslRules = parsedJson.dsl_rules ? parsedJson.dsl_rules.trim() : '';
                    $('ruleInput').value = dslRules || 'Error generating DSL.';

                    if (dslRules) {
                        // Parse the DSL rules
                        const rules = parseRules(dslRules);

                        // Fetch candidate words from bestwordlist.com
                        $('buttonText').textContent = 'Fetching Words...';
                        $('wordListInput').value = 'Fetching words from bestwordlist.com...';
                        $('results').innerHTML = '<p class="text-gray-500 text-sm p-2">Step 2: Fetching candidate words from bestwordlist.com...</p>';

                        const allWords = await fetchWordListByPosition(rules);

                        if (allWords.length === 0) {
                            $('wordListInput').value = 'No words found. Make sure there is at least one exact position constraint.';
                            $('results').innerHTML = '<p class="text-red-500 font-semibold p-2">No words fetched. Exact position constraints are required.</p>';
                            return;
                        }

                        // Filter words based on all rules
                        $('validationStatus').textContent = 'Filtering words based on all constraints...';
                        const candidateWords = allWords.filter(word => checkDeterministicRules(word, rules));

                        // Display the candidate words
                        $('wordListInput').value = candidateWords.join('\n');
                        $('wordListCount').textContent = `(${candidateWords.length} words found)`;
                        $('validationStatus').className = 'validation-status bg-green-200 text-green-800 ml-2';
                        $('validationStatus').textContent = `Found ${candidateWords.length} valid Scrabble words!`;

                        // Display results
                        const resultsDiv = $('results');
                        resultsDiv.innerHTML = '';
                        candidateWords.forEach(word => {
                            const wordElement = document.createElement('div');
                            wordElement.className = 'text-lg font-mono p-2 bg-white border border-green-300 rounded-lg hover:bg-green-50 cursor-pointer';
                            wordElement.textContent = word;
                            resultsDiv.appendChild(wordElement);
                        });
                        $('resultCount').textContent = candidateWords.length;
                    }
                } else {
                    $('ruleInput').value = "Error: Could not generate DSL. Check console for details.";
                    $('wordListInput').value = "Error: Could not generate DSL. Check console for details.";
                    $('resultCount').textContent = 0;
                }

            } catch (error) {
                console.error("Error during word fetching:", error);
                $('ruleInput').value = `Error: ${error.message}`;
                $('results').innerHTML = `<p class="text-red-500 font-semibold p-2">An error occurred: ${error.message.substring(0, 80)}</p>`;
            } finally {
                // Reset loading state
                $('loadingIndicator').classList.add('hidden');
                $('buttonText').textContent = 'Generate DSL & Fetch Candidate Words';
                $('generateButton').disabled = false;
            }
        }


        // --- DSL Validation Logic ---

        /**
         * Parses the raw text rules into a structured DSL object.
         */
        function parseRules(rawRules) {
            const rules = {
                exact: {},
                present: {},
                absent: new Set(),
                length: 5, // Default Wordle length
            };

            const lines = rawRules.toUpperCase().split('\n').map(line => line.trim()).filter(line => line.length > 0);

            for (const line of lines) {
                // 1. Exact Match (Green): 'O AT 3', 'A AT 1' (1-based index)
                const exactMatch = line.match(/^([A-Z]) AT (\d)$/);
                if (exactMatch) {
                    const position = parseInt(exactMatch[2], 10);
                    if (position >= 1 && position <= 9) { 
                        rules.exact[position - 1] = exactMatch[1];
                        continue;
                    }
                }

                // 2. Absent (Gray): 'NO S, T, R, E' or 'NO S'
                const absentMatch = line.match(/^NO\s+([A-Z, ]+)$/);
                if (absentMatch) {
                    const letters = absentMatch[1].split(',').map(l => l.trim()).filter(l => l.length === 1);
                    letters.forEach(letter => rules.absent.add(letter));
                    continue;
                }

                // 3. Present (Yellow): 'A IN WORD' or 'A IN WORD, NOT AT 5'
                const presentMatch = line.match(/^([A-Z]) IN WORD/);
                if (presentMatch) {
                    const letter = presentMatch[1];
                    let disallowedPositions = [];

                    const notAtMatch = line.match(/NOT AT ([\d, ]+)$/);
                    if (notAtMatch) {
                        disallowedPositions = notAtMatch[1].split(',')
                            .map(p => parseInt(p.trim(), 10) - 1) 
                            .filter(p => p >= 0); 
                    }

                    rules.present[letter] = disallowedPositions;
                    continue;
                }

                // 4. Word Length: 'LENGTH: 5'
                const lengthMatch = line.match(/^LENGTH:\s*(\d+)$/);
                if (lengthMatch) {
                    rules.length = parseInt(lengthMatch[1], 10);
                    continue;
                }
            }

            // Cleanup: ensure 'present' or 'exact' letters are not in the absent list
            for(const letter in rules.present) {
                rules.absent.delete(letter);
            }
            for(const index in rules.exact) {
                rules.absent.delete(rules.exact[index]);
            }

            rules.absent = Array.from(rules.absent);
            return rules;
        }

        /**
         * Checks if a single word satisfies all the deterministic Wordle rules (excluding dictionary check).
         */
        function checkDeterministicRules(word, rules) {
            // 1. Check Length Constraint
            if (word.length !== rules.length) {
                return false;
            }

            // 2. Check Exact Matches (Green)
            for (const indexStr in rules.exact) {
                const index = parseInt(indexStr);
                if (word[index] !== rules.exact[index]) {
                    return false;
                }
            }

            // 3. Check Absent Letters (Gray)
            for (const letter of rules.absent) {
                if (word.includes(letter)) {
                    return false;
                }
            }

            // 4. Check Present Letters (Yellow)
            for (const letter in rules.present) {
                // Check 4a: Letter MUST be present in the word
                if (!word.includes(letter)) {
                    return false;
                }

                // Check 4b: Letter MUST NOT be in the disallowed positions
                const disallowedPositions = rules.present[letter];
                let isLetterInDisallowedPosition = false;
                for (const index of disallowedPositions) {
                    if (word[index] === letter) {
                        isLetterInDisallowedPosition = true;
                        break;
                    }
                }
                if (isLetterInDisallowedPosition) {
                    return false;
                }
            }
            
            return true;
        }

        // Initialize the app on load
        window.onload = function() {
            // Set initial rules using the preferred DSL format
            $('ruleInput').value = "O at 3\nA in word\nno S, T, R, E, C, L, U, D\nLENGTH: 5";
        };

    </script>
</body>
</html>